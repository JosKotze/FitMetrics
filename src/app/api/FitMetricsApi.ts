//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: RegisterDto | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginDto | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param accessToken (optional) 
     * @return OK
     */
    getActivitiesFromStrava(accessToken: string | undefined): Promise<StravaActivityData[]> {
        let url_ = this.baseUrl + "/api/Activities/getActivitiesFromStrava?";
        if (accessToken === null)
            throw new Error("The parameter 'accessToken' cannot be null.");
        else if (accessToken !== undefined)
            url_ += "accessToken=" + encodeURIComponent("" + accessToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivitiesFromStrava(_response);
        });
    }

    protected processGetActivitiesFromStrava(response: Response): Promise<StravaActivityData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StravaActivityData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StravaActivityData[]>(null as any);
    }

    /**
     * @return OK
     */
    getActivitiesFromFitMetrics(): Promise<Activity[]> {
        let url_ = this.baseUrl + "/api/Activities/getActivitiesFromFitMetrics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivitiesFromFitMetrics(_response);
        });
    }

    protected processGetActivitiesFromFitMetrics(response: Response): Promise<Activity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Activity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity[]>(null as any);
    }

    /**
     * @param accessToken (optional) 
     * @return OK
     */
    saveActivitiesFromStrava(accessToken: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Activities/saveActivitiesFromStrava?";
        if (accessToken === null)
            throw new Error("The parameter 'accessToken' cannot be null.");
        else if (accessToken !== undefined)
            url_ += "accessToken=" + encodeURIComponent("" + accessToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveActivitiesFromStrava(_response);
        });
    }

    protected processSaveActivitiesFromStrava(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getSavedActivities(): Promise<Activity[]> {
        let url_ = this.baseUrl + "/api/Activities/getSavedActivities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSavedActivities(_response);
        });
    }

    protected processGetSavedActivities(response: Response): Promise<Activity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Activity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity[]>(null as any);
    }

    /**
     * @return OK
     */
    users(): Promise<User[]> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers(_response);
        });
    }

    protected processUsers(response: Response): Promise<User[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User[]>(null as any);
    }
}

export class Activity implements IActivity {
    id?: number;
    pace?: string | undefined;
    name?: string | undefined;
    distance?: number;
    movingTime?: number;
    totalElevationGain?: number;
    type?: string | undefined;
    startDate?: Date | undefined;
    startDateLocal?: Date | undefined;
    timezone?: string | undefined;
    utcOffset?: number | undefined;
    locationCity?: string | undefined;
    locationState?: string | undefined;
    locationCountry?: string | undefined;
    achievementCount?: number | undefined;
    averageSpeed?: number;
    maxSpeed?: number;
    averageWatts?: number | undefined;
    kilojoules?: number | undefined;
    deviceWatts?: boolean | undefined;
    averageHeartrate?: number | undefined;
    maxHeartrate?: number | undefined;
    userId?: number;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pace = _data["pace"];
            this.name = _data["name"];
            this.distance = _data["distance"];
            this.movingTime = _data["movingTime"];
            this.totalElevationGain = _data["totalElevationGain"];
            this.type = _data["type"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.startDateLocal = _data["startDateLocal"] ? new Date(_data["startDateLocal"].toString()) : <any>undefined;
            this.timezone = _data["timezone"];
            this.utcOffset = _data["utcOffset"];
            this.locationCity = _data["locationCity"];
            this.locationState = _data["locationState"];
            this.locationCountry = _data["locationCountry"];
            this.achievementCount = _data["achievementCount"];
            this.averageSpeed = _data["averageSpeed"];
            this.maxSpeed = _data["maxSpeed"];
            this.averageWatts = _data["averageWatts"];
            this.kilojoules = _data["kilojoules"];
            this.deviceWatts = _data["deviceWatts"];
            this.averageHeartrate = _data["averageHeartrate"];
            this.maxHeartrate = _data["maxHeartrate"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pace"] = this.pace;
        data["name"] = this.name;
        data["distance"] = this.distance;
        data["movingTime"] = this.movingTime;
        data["totalElevationGain"] = this.totalElevationGain;
        data["type"] = this.type;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startDateLocal"] = this.startDateLocal ? this.startDateLocal.toISOString() : <any>undefined;
        data["timezone"] = this.timezone;
        data["utcOffset"] = this.utcOffset;
        data["locationCity"] = this.locationCity;
        data["locationState"] = this.locationState;
        data["locationCountry"] = this.locationCountry;
        data["achievementCount"] = this.achievementCount;
        data["averageSpeed"] = this.averageSpeed;
        data["maxSpeed"] = this.maxSpeed;
        data["averageWatts"] = this.averageWatts;
        data["kilojoules"] = this.kilojoules;
        data["deviceWatts"] = this.deviceWatts;
        data["averageHeartrate"] = this.averageHeartrate;
        data["maxHeartrate"] = this.maxHeartrate;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IActivity {
    id?: number;
    pace?: string | undefined;
    name?: string | undefined;
    distance?: number;
    movingTime?: number;
    totalElevationGain?: number;
    type?: string | undefined;
    startDate?: Date | undefined;
    startDateLocal?: Date | undefined;
    timezone?: string | undefined;
    utcOffset?: number | undefined;
    locationCity?: string | undefined;
    locationState?: string | undefined;
    locationCountry?: string | undefined;
    achievementCount?: number | undefined;
    averageSpeed?: number;
    maxSpeed?: number;
    averageWatts?: number | undefined;
    kilojoules?: number | undefined;
    deviceWatts?: boolean | undefined;
    averageHeartrate?: number | undefined;
    maxHeartrate?: number | undefined;
    userId?: number;
}

export class LoginDto implements ILoginDto {
    username!: string;
    password!: string;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginDto {
    username: string;
    password: string;
}

export class Map implements IMap {

    constructor(data?: IMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Map {
        data = typeof data === 'object' ? data : {};
        let result = new Map();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IMap {
}

export class RegisterDto implements IRegisterDto {
    username!: string;
    password!: string;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterDto {
    username: string;
    password: string;
}

export class StravaActivityData implements IStravaActivityData {
    pace?: string | undefined;
    resourceState?: number;
    athlete?: User;
    name?: string | undefined;
    distance?: number;
    movingTime?: number;
    elapsedTime?: number;
    totalElevationGain?: number;
    type?: string | undefined;
    sportType?: string | undefined;
    workoutType?: number | undefined;
    id?: number;
    startDate?: Date | undefined;
    startDateLocal?: Date | undefined;
    timezone?: string | undefined;
    utcOffset?: number | undefined;
    locationCity?: string | undefined;
    locationState?: string | undefined;
    locationCountry?: string | undefined;
    achievementCount?: number | undefined;
    kudosCount?: number | undefined;
    commentCount?: number | undefined;
    athleteCount?: number | undefined;
    photoCount?: number | undefined;
    map?: Map;
    trainer?: boolean | undefined;
    commute?: boolean | undefined;
    manual?: boolean | undefined;
    private?: boolean | undefined;
    visibility?: string | undefined;
    flagged?: boolean | undefined;
    gearId?: string | undefined;
    startLatlng?: number[] | undefined;
    endLatlng?: number[] | undefined;
    averageSpeed?: number;
    maxSpeed?: number;
    hasHeartrate?: boolean;
    heartrateOptOut?: boolean;
    displayHideHeartrateOption?: boolean;
    uploadId?: number | undefined;
    externalId?: string | undefined;
    fromAcceptedTag?: boolean;
    prCount?: number;
    totalPhotoCount?: number;
    hasKudoed?: boolean;
    averageWatts?: number | undefined;
    kilojoules?: number | undefined;
    deviceWatts?: boolean | undefined;
    averageHeartrate?: number | undefined;
    maxHeartrate?: number | undefined;
    elevHigh?: number | undefined;
    elevLow?: number | undefined;
    userId?: number;

    constructor(data?: IStravaActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pace = _data["pace"];
            this.resourceState = _data["resourceState"];
            this.athlete = _data["athlete"] ? User.fromJS(_data["athlete"]) : <any>undefined;
            this.name = _data["name"];
            this.distance = _data["distance"];
            this.movingTime = _data["movingTime"];
            this.elapsedTime = _data["elapsedTime"];
            this.totalElevationGain = _data["totalElevationGain"];
            this.type = _data["type"];
            this.sportType = _data["sportType"];
            this.workoutType = _data["workoutType"];
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.startDateLocal = _data["startDateLocal"] ? new Date(_data["startDateLocal"].toString()) : <any>undefined;
            this.timezone = _data["timezone"];
            this.utcOffset = _data["utcOffset"];
            this.locationCity = _data["locationCity"];
            this.locationState = _data["locationState"];
            this.locationCountry = _data["locationCountry"];
            this.achievementCount = _data["achievementCount"];
            this.kudosCount = _data["kudosCount"];
            this.commentCount = _data["commentCount"];
            this.athleteCount = _data["athleteCount"];
            this.photoCount = _data["photoCount"];
            this.map = _data["map"] ? Map.fromJS(_data["map"]) : <any>undefined;
            this.trainer = _data["trainer"];
            this.commute = _data["commute"];
            this.manual = _data["manual"];
            this.private = _data["private"];
            this.visibility = _data["visibility"];
            this.flagged = _data["flagged"];
            this.gearId = _data["gearId"];
            if (Array.isArray(_data["startLatlng"])) {
                this.startLatlng = [] as any;
                for (let item of _data["startLatlng"])
                    this.startLatlng!.push(item);
            }
            if (Array.isArray(_data["endLatlng"])) {
                this.endLatlng = [] as any;
                for (let item of _data["endLatlng"])
                    this.endLatlng!.push(item);
            }
            this.averageSpeed = _data["averageSpeed"];
            this.maxSpeed = _data["maxSpeed"];
            this.hasHeartrate = _data["hasHeartrate"];
            this.heartrateOptOut = _data["heartrateOptOut"];
            this.displayHideHeartrateOption = _data["displayHideHeartrateOption"];
            this.uploadId = _data["uploadId"];
            this.externalId = _data["externalId"];
            this.fromAcceptedTag = _data["fromAcceptedTag"];
            this.prCount = _data["prCount"];
            this.totalPhotoCount = _data["totalPhotoCount"];
            this.hasKudoed = _data["hasKudoed"];
            this.averageWatts = _data["averageWatts"];
            this.kilojoules = _data["kilojoules"];
            this.deviceWatts = _data["deviceWatts"];
            this.averageHeartrate = _data["averageHeartrate"];
            this.maxHeartrate = _data["maxHeartrate"];
            this.elevHigh = _data["elevHigh"];
            this.elevLow = _data["elevLow"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): StravaActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new StravaActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pace"] = this.pace;
        data["resourceState"] = this.resourceState;
        data["athlete"] = this.athlete ? this.athlete.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["distance"] = this.distance;
        data["movingTime"] = this.movingTime;
        data["elapsedTime"] = this.elapsedTime;
        data["totalElevationGain"] = this.totalElevationGain;
        data["type"] = this.type;
        data["sportType"] = this.sportType;
        data["workoutType"] = this.workoutType;
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startDateLocal"] = this.startDateLocal ? this.startDateLocal.toISOString() : <any>undefined;
        data["timezone"] = this.timezone;
        data["utcOffset"] = this.utcOffset;
        data["locationCity"] = this.locationCity;
        data["locationState"] = this.locationState;
        data["locationCountry"] = this.locationCountry;
        data["achievementCount"] = this.achievementCount;
        data["kudosCount"] = this.kudosCount;
        data["commentCount"] = this.commentCount;
        data["athleteCount"] = this.athleteCount;
        data["photoCount"] = this.photoCount;
        data["map"] = this.map ? this.map.toJSON() : <any>undefined;
        data["trainer"] = this.trainer;
        data["commute"] = this.commute;
        data["manual"] = this.manual;
        data["private"] = this.private;
        data["visibility"] = this.visibility;
        data["flagged"] = this.flagged;
        data["gearId"] = this.gearId;
        if (Array.isArray(this.startLatlng)) {
            data["startLatlng"] = [];
            for (let item of this.startLatlng)
                data["startLatlng"].push(item);
        }
        if (Array.isArray(this.endLatlng)) {
            data["endLatlng"] = [];
            for (let item of this.endLatlng)
                data["endLatlng"].push(item);
        }
        data["averageSpeed"] = this.averageSpeed;
        data["maxSpeed"] = this.maxSpeed;
        data["hasHeartrate"] = this.hasHeartrate;
        data["heartrateOptOut"] = this.heartrateOptOut;
        data["displayHideHeartrateOption"] = this.displayHideHeartrateOption;
        data["uploadId"] = this.uploadId;
        data["externalId"] = this.externalId;
        data["fromAcceptedTag"] = this.fromAcceptedTag;
        data["prCount"] = this.prCount;
        data["totalPhotoCount"] = this.totalPhotoCount;
        data["hasKudoed"] = this.hasKudoed;
        data["averageWatts"] = this.averageWatts;
        data["kilojoules"] = this.kilojoules;
        data["deviceWatts"] = this.deviceWatts;
        data["averageHeartrate"] = this.averageHeartrate;
        data["maxHeartrate"] = this.maxHeartrate;
        data["elevHigh"] = this.elevHigh;
        data["elevLow"] = this.elevLow;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IStravaActivityData {
    pace?: string | undefined;
    resourceState?: number;
    athlete?: User;
    name?: string | undefined;
    distance?: number;
    movingTime?: number;
    elapsedTime?: number;
    totalElevationGain?: number;
    type?: string | undefined;
    sportType?: string | undefined;
    workoutType?: number | undefined;
    id?: number;
    startDate?: Date | undefined;
    startDateLocal?: Date | undefined;
    timezone?: string | undefined;
    utcOffset?: number | undefined;
    locationCity?: string | undefined;
    locationState?: string | undefined;
    locationCountry?: string | undefined;
    achievementCount?: number | undefined;
    kudosCount?: number | undefined;
    commentCount?: number | undefined;
    athleteCount?: number | undefined;
    photoCount?: number | undefined;
    map?: Map;
    trainer?: boolean | undefined;
    commute?: boolean | undefined;
    manual?: boolean | undefined;
    private?: boolean | undefined;
    visibility?: string | undefined;
    flagged?: boolean | undefined;
    gearId?: string | undefined;
    startLatlng?: number[] | undefined;
    endLatlng?: number[] | undefined;
    averageSpeed?: number;
    maxSpeed?: number;
    hasHeartrate?: boolean;
    heartrateOptOut?: boolean;
    displayHideHeartrateOption?: boolean;
    uploadId?: number | undefined;
    externalId?: string | undefined;
    fromAcceptedTag?: boolean;
    prCount?: number;
    totalPhotoCount?: number;
    hasKudoed?: boolean;
    averageWatts?: number | undefined;
    kilojoules?: number | undefined;
    deviceWatts?: boolean | undefined;
    averageHeartrate?: number | undefined;
    maxHeartrate?: number | undefined;
    elevHigh?: number | undefined;
    elevLow?: number | undefined;
    userId?: number;
}

export class User implements IUser {
    id?: number;
    userName!: string | undefined;
    passwordHash!: string | undefined;
    passwordSalt!: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.passwordHash = _data["passwordHash"];
            this.passwordSalt = _data["passwordSalt"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["passwordHash"] = this.passwordHash;
        data["passwordSalt"] = this.passwordSalt;
        return data;
    }
}

export interface IUser {
    id?: number;
    userName: string | undefined;
    passwordHash: string | undefined;
    passwordSalt: string | undefined;
}

export class UserDto implements IUserDto {
    userName!: string | undefined;
    token!: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["token"] = this.token;
        return data;
    }
}

export interface IUserDto {
    userName: string | undefined;
    token: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}