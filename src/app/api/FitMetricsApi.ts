//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf, of } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('https://localhost:7279');

@Injectable()
export class FitMetricsApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    activities(): Observable<Activity[]> {
        let url_ = this.baseUrl + "/api/Activities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processActivities(response_);
          }),
          _observableCatch((error: any) => {
            // Handle error appropriately, e.g., log the error and return an empty observable
            console.error("Error fetching activities:", error);
            return of([]);
          })
        );
    }

    protected processActivities(response: HttpResponseBase): Observable<Activity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Activity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    authCodeCallbackAll(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/AuthCodeCallback";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthCodeCallbackAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthCodeCallbackAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processAuthCodeCallbackAll(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    authCodeCallbackPOST(body: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthCodeCallback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthCodeCallbackPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthCodeCallbackPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuthCodeCallbackPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    authCodeCallbackGET(id: number): Observable<string> {
        let url_ = this.baseUrl + "/api/AuthCodeCallback/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthCodeCallbackGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthCodeCallbackGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAuthCodeCallbackGET(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    authCodeCallbackPUT(id: number, body: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthCodeCallback/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthCodeCallbackPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthCodeCallbackPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuthCodeCallbackPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    authCodeCallbackDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthCodeCallback/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthCodeCallbackDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthCodeCallbackDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuthCodeCallbackDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param email (optional) 
     * @param name (optional) 
     * @param surname (optional) 
     * @param passwordHash (optional) 
     * @param accessToken (optional) 
     * @param refreshToken (optional) 
     * @param refreshTokenCreated (optional) 
     * @return OK
     */
    signup(id: number | undefined, email: string | undefined, name: string | undefined, surname: string | undefined, passwordHash: string | undefined, accessToken: string | undefined, refreshToken: string | undefined, refreshTokenCreated: Date | undefined): Observable<void> {
        let url_ = this.baseUrl + "/signup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (surname === null)
            throw new Error("The parameter 'surname' cannot be null.");
        else if (surname !== undefined)
            url_ += "Surname=" + encodeURIComponent("" + surname) + "&";
        if (passwordHash === null)
            throw new Error("The parameter 'passwordHash' cannot be null.");
        else if (passwordHash !== undefined)
            url_ += "PasswordHash=" + encodeURIComponent("" + passwordHash) + "&";
        if (accessToken === null)
            throw new Error("The parameter 'accessToken' cannot be null.");
        else if (accessToken !== undefined)
            url_ += "AccessToken=" + encodeURIComponent("" + accessToken) + "&";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "RefreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        if (refreshTokenCreated === null)
            throw new Error("The parameter 'refreshTokenCreated' cannot be null.");
        else if (refreshTokenCreated !== undefined)
            url_ += "RefreshTokenCreated=" + encodeURIComponent(refreshTokenCreated ? "" + refreshTokenCreated.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param email (optional) 
     * @param password (optional) 
     * @return OK
     */
    login(name: string | undefined, email: string | undefined, password: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/login?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getWeatherForecast(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeatherForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeatherForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGetWeatherForecast(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Activity implements IActivity {
    pace?: string | undefined;
    resource_state?: number;
    athlete?: Athlete;
    name?: string | undefined;
    distance?: number;
    moving_time?: number;
    elapsed_time?: number;
    total_elevation_gain?: number;
    type?: string | undefined;
    sport_type?: string | undefined;
    workout_type?: number | undefined;
    id?: number;
    start_date?: Date;
    start_date_local?: Date;
    timezone?: string | undefined;
    utc_offset?: number;
    location_city?: string | undefined;
    location_state?: string | undefined;
    location_country?: string | undefined;
    achievement_count?: number;
    kudos_count?: number;
    comment_count?: number;
    athlete_count?: number;
    photo_count?: number;
    map?: Map;
    trainer?: boolean;
    commute?: boolean;
    manual?: boolean;
    private?: boolean;
    visibility?: string | undefined;
    flagged?: boolean;
    gear_id?: string | undefined;
    start_latlng?: number[] | undefined;
    end_latlng?: number[] | undefined;
    average_speed?: number;
    max_speed?: number;
    has_heartrate?: boolean;
    heartrate_opt_out?: boolean;
    display_hide_heartrate_option?: boolean;
    upload_id?: number | undefined;
    external_id?: string | undefined;
    from_accepted_tag?: boolean;
    pr_count?: number;
    total_photo_count?: number;
    has_kudoed?: boolean;
    average_watts?: number | undefined;
    kilojoules?: number | undefined;
    device_watts?: boolean | undefined;
    average_heartrate?: number | undefined;
    max_heartrate?: number | undefined;
    elev_high?: number | undefined;
    elev_low?: number | undefined;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pace = _data["pace"];
            this.resource_state = _data["resource_state"];
            this.athlete = _data["athlete"] ? Athlete.fromJS(_data["athlete"]) : <any>undefined;
            this.name = _data["name"];
            this.distance = _data["distance"];
            this.moving_time = _data["moving_time"];
            this.elapsed_time = _data["elapsed_time"];
            this.total_elevation_gain = _data["total_elevation_gain"];
            this.type = _data["type"];
            this.sport_type = _data["sport_type"];
            this.workout_type = _data["workout_type"];
            this.id = _data["id"];
            this.start_date = _data["start_date"] ? new Date(_data["start_date"].toString()) : <any>undefined;
            this.start_date_local = _data["start_date_local"] ? new Date(_data["start_date_local"].toString()) : <any>undefined;
            this.timezone = _data["timezone"];
            this.utc_offset = _data["utc_offset"];
            this.location_city = _data["location_city"];
            this.location_state = _data["location_state"];
            this.location_country = _data["location_country"];
            this.achievement_count = _data["achievement_count"];
            this.kudos_count = _data["kudos_count"];
            this.comment_count = _data["comment_count"];
            this.athlete_count = _data["athlete_count"];
            this.photo_count = _data["photo_count"];
            this.map = _data["map"] ? Map.fromJS(_data["map"]) : <any>undefined;
            this.trainer = _data["trainer"];
            this.commute = _data["commute"];
            this.manual = _data["manual"];
            this.private = _data["private"];
            this.visibility = _data["visibility"];
            this.flagged = _data["flagged"];
            this.gear_id = _data["gear_id"];
            if (Array.isArray(_data["start_latlng"])) {
                this.start_latlng = [] as any;
                for (let item of _data["start_latlng"])
                    this.start_latlng!.push(item);
            }
            if (Array.isArray(_data["end_latlng"])) {
                this.end_latlng = [] as any;
                for (let item of _data["end_latlng"])
                    this.end_latlng!.push(item);
            }
            this.average_speed = _data["average_speed"];
            this.max_speed = _data["max_speed"];
            this.has_heartrate = _data["has_heartrate"];
            this.heartrate_opt_out = _data["heartrate_opt_out"];
            this.display_hide_heartrate_option = _data["display_hide_heartrate_option"];
            this.upload_id = _data["upload_id"];
            this.external_id = _data["external_id"];
            this.from_accepted_tag = _data["from_accepted_tag"];
            this.pr_count = _data["pr_count"];
            this.total_photo_count = _data["total_photo_count"];
            this.has_kudoed = _data["has_kudoed"];
            this.average_watts = _data["average_watts"];
            this.kilojoules = _data["kilojoules"];
            this.device_watts = _data["device_watts"];
            this.average_heartrate = _data["average_heartrate"];
            this.max_heartrate = _data["max_heartrate"];
            this.elev_high = _data["elev_high"];
            this.elev_low = _data["elev_low"];
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pace"] = this.pace;
        data["resource_state"] = this.resource_state;
        data["athlete"] = this.athlete ? this.athlete.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["distance"] = this.distance;
        data["moving_time"] = this.moving_time;
        data["elapsed_time"] = this.elapsed_time;
        data["total_elevation_gain"] = this.total_elevation_gain;
        data["type"] = this.type;
        data["sport_type"] = this.sport_type;
        data["workout_type"] = this.workout_type;
        data["id"] = this.id;
        data["start_date"] = this.start_date ? this.start_date.toISOString() : <any>undefined;
        data["start_date_local"] = this.start_date_local ? this.start_date_local.toISOString() : <any>undefined;
        data["timezone"] = this.timezone;
        data["utc_offset"] = this.utc_offset;
        data["location_city"] = this.location_city;
        data["location_state"] = this.location_state;
        data["location_country"] = this.location_country;
        data["achievement_count"] = this.achievement_count;
        data["kudos_count"] = this.kudos_count;
        data["comment_count"] = this.comment_count;
        data["athlete_count"] = this.athlete_count;
        data["photo_count"] = this.photo_count;
        data["map"] = this.map ? this.map.toJSON() : <any>undefined;
        data["trainer"] = this.trainer;
        data["commute"] = this.commute;
        data["manual"] = this.manual;
        data["private"] = this.private;
        data["visibility"] = this.visibility;
        data["flagged"] = this.flagged;
        data["gear_id"] = this.gear_id;
        if (Array.isArray(this.start_latlng)) {
            data["start_latlng"] = [];
            for (let item of this.start_latlng)
                data["start_latlng"].push(item);
        }
        if (Array.isArray(this.end_latlng)) {
            data["end_latlng"] = [];
            for (let item of this.end_latlng)
                data["end_latlng"].push(item);
        }
        data["average_speed"] = this.average_speed;
        data["max_speed"] = this.max_speed;
        data["has_heartrate"] = this.has_heartrate;
        data["heartrate_opt_out"] = this.heartrate_opt_out;
        data["display_hide_heartrate_option"] = this.display_hide_heartrate_option;
        data["upload_id"] = this.upload_id;
        data["external_id"] = this.external_id;
        data["from_accepted_tag"] = this.from_accepted_tag;
        data["pr_count"] = this.pr_count;
        data["total_photo_count"] = this.total_photo_count;
        data["has_kudoed"] = this.has_kudoed;
        data["average_watts"] = this.average_watts;
        data["kilojoules"] = this.kilojoules;
        data["device_watts"] = this.device_watts;
        data["average_heartrate"] = this.average_heartrate;
        data["max_heartrate"] = this.max_heartrate;
        data["elev_high"] = this.elev_high;
        data["elev_low"] = this.elev_low;
        return data;
    }
}

export interface IActivity {
    pace?: string | undefined;
    resource_state?: number;
    athlete?: Athlete;
    name?: string | undefined;
    distance?: number;
    moving_time?: number;
    elapsed_time?: number;
    total_elevation_gain?: number;
    type?: string | undefined;
    sport_type?: string | undefined;
    workout_type?: number | undefined;
    id?: number;
    start_date?: Date;
    start_date_local?: Date;
    timezone?: string | undefined;
    utc_offset?: number;
    location_city?: string | undefined;
    location_state?: string | undefined;
    location_country?: string | undefined;
    achievement_count?: number;
    kudos_count?: number;
    comment_count?: number;
    athlete_count?: number;
    photo_count?: number;
    map?: Map;
    trainer?: boolean;
    commute?: boolean;
    manual?: boolean;
    private?: boolean;
    visibility?: string | undefined;
    flagged?: boolean;
    gear_id?: string | undefined;
    start_latlng?: number[] | undefined;
    end_latlng?: number[] | undefined;
    average_speed?: number;
    max_speed?: number;
    has_heartrate?: boolean;
    heartrate_opt_out?: boolean;
    display_hide_heartrate_option?: boolean;
    upload_id?: number | undefined;
    external_id?: string | undefined;
    from_accepted_tag?: boolean;
    pr_count?: number;
    total_photo_count?: number;
    has_kudoed?: boolean;
    average_watts?: number | undefined;
    kilojoules?: number | undefined;
    device_watts?: boolean | undefined;
    average_heartrate?: number | undefined;
    max_heartrate?: number | undefined;
    elev_high?: number | undefined;
    elev_low?: number | undefined;
}

export class Athlete implements IAthlete {
    id?: number;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    passwordHash?: string | undefined;
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    refreshTokenCreated?: Date;

    constructor(data?: IAthlete) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.passwordHash = _data["passwordHash"];
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenCreated = _data["refreshTokenCreated"] ? new Date(_data["refreshTokenCreated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Athlete {
        data = typeof data === 'object' ? data : {};
        let result = new Athlete();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["passwordHash"] = this.passwordHash;
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenCreated"] = this.refreshTokenCreated ? this.refreshTokenCreated.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAthlete {
    id?: number;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    passwordHash?: string | undefined;
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    refreshTokenCreated?: Date;
}

export class Map implements IMap {
    id?: string | undefined;
    summary_polyline?: string | undefined;
    resource_state?: number;

    constructor(data?: IMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.summary_polyline = _data["summary_polyline"];
            this.resource_state = _data["resource_state"];
        }
    }

    static fromJS(data: any): Map {
        data = typeof data === 'object' ? data : {};
        let result = new Map();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["summary_polyline"] = this.summary_polyline;
        data["resource_state"] = this.resource_state;
        return data;
    }
}

export interface IMap {
    id?: string | undefined;
    summary_polyline?: string | undefined;
    resource_state?: number;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}